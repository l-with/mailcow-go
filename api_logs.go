/*
mailcow API

mailcow is complete e-mailing solution with advanced antispam, antivirus, nice UI and API.  In order to use this API you have to create a API key and add your IP address to the whitelist of allowed IPs this can be done by logging into the Mailcow UI using your admin account, then go to Configuration > Access > Edit administrator details > API. There you will find a collapsed API menu.  There are two types of API keys   - The read only key can only be used for all get endpoints   - The read write key can be used for all endpoints

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// LogsApiService LogsApi service
type LogsApiService service

type ApiGetACMELogsRequest struct {
	ctx        context.Context
	ApiService *LogsApiService
	count      float32
	xAPIKey    *string
}

// e.g. api-key-string
func (r ApiGetACMELogsRequest) XAPIKey(xAPIKey string) ApiGetACMELogsRequest {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetACMELogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetACMELogsExecute(r)
}

/*
GetACMELogs Get ACME logs

This Api endpoint lists all ACME logs from issued Lets Enctypts certificates.
Tip: You can limit how many logs you want to get by using `/<count>` at the end of the api url.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param count Number of logs to return
 @return ApiGetACMELogsRequest
*/
func (a *LogsApiService) GetACMELogs(ctx context.Context, count float32) ApiGetACMELogsRequest {
	return ApiGetACMELogsRequest{
		ApiService: a,
		ctx:        ctx,
		count:      count,
	}
}

// Execute executes the request
func (a *LogsApiService) GetACMELogsExecute(r ApiGetACMELogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogsApiService.GetACMELogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/get/logs/acme/{count}"
	localVarPath = strings.Replace(localVarPath, "{"+"count"+"}", url.PathEscape(parameterToString(r.count, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v CreateAlias401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetApiLogsRequest struct {
	ctx        context.Context
	ApiService *LogsApiService
	count      float32
	xAPIKey    *string
}

// e.g. api-key-string
func (r ApiGetApiLogsRequest) XAPIKey(xAPIKey string) ApiGetApiLogsRequest {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetApiLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetApiLogsExecute(r)
}

/*
GetApiLogs Get Api logs

This Api endpoint lists all Api logs.
Tip: You can limit how many logs you want to get by using `/<count>` at the end of the api url.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param count Number of logs to return
 @return ApiGetApiLogsRequest
*/
func (a *LogsApiService) GetApiLogs(ctx context.Context, count float32) ApiGetApiLogsRequest {
	return ApiGetApiLogsRequest{
		ApiService: a,
		ctx:        ctx,
		count:      count,
	}
}

// Execute executes the request
func (a *LogsApiService) GetApiLogsExecute(r ApiGetApiLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogsApiService.GetApiLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/get/logs/api/{count}"
	localVarPath = strings.Replace(localVarPath, "{"+"count"+"}", url.PathEscape(parameterToString(r.count, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v CreateAlias401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAutodiscoverLogsRequest struct {
	ctx        context.Context
	ApiService *LogsApiService
	count      float32
	xAPIKey    *string
}

// e.g. api-key-string
func (r ApiGetAutodiscoverLogsRequest) XAPIKey(xAPIKey string) ApiGetAutodiscoverLogsRequest {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetAutodiscoverLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetAutodiscoverLogsExecute(r)
}

/*
GetAutodiscoverLogs Get Autodiscover logs

This Api endpoint lists all Autodiscover logs.
Tip: You can limit how many logs you want to get by using `/<count>` at the end of the api url.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param count Number of logs to return
 @return ApiGetAutodiscoverLogsRequest
*/
func (a *LogsApiService) GetAutodiscoverLogs(ctx context.Context, count float32) ApiGetAutodiscoverLogsRequest {
	return ApiGetAutodiscoverLogsRequest{
		ApiService: a,
		ctx:        ctx,
		count:      count,
	}
}

// Execute executes the request
func (a *LogsApiService) GetAutodiscoverLogsExecute(r ApiGetAutodiscoverLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogsApiService.GetAutodiscoverLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/get/logs/autodiscover/{count}"
	localVarPath = strings.Replace(localVarPath, "{"+"count"+"}", url.PathEscape(parameterToString(r.count, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v CreateAlias401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDovecotLogsRequest struct {
	ctx        context.Context
	ApiService *LogsApiService
	count      float32
	xAPIKey    *string
}

// e.g. api-key-string
func (r ApiGetDovecotLogsRequest) XAPIKey(xAPIKey string) ApiGetDovecotLogsRequest {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetDovecotLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetDovecotLogsExecute(r)
}

/*
GetDovecotLogs Get Dovecot logs

This Api endpoint lists all Dovecot logs.
Tip: You can limit how many logs you want to get by using `/<count>` at the end of the api url.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param count Number of logs to return
 @return ApiGetDovecotLogsRequest
*/
func (a *LogsApiService) GetDovecotLogs(ctx context.Context, count float32) ApiGetDovecotLogsRequest {
	return ApiGetDovecotLogsRequest{
		ApiService: a,
		ctx:        ctx,
		count:      count,
	}
}

// Execute executes the request
func (a *LogsApiService) GetDovecotLogsExecute(r ApiGetDovecotLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogsApiService.GetDovecotLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/get/logs/dovecot/{count}"
	localVarPath = strings.Replace(localVarPath, "{"+"count"+"}", url.PathEscape(parameterToString(r.count, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v CreateAlias401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetNetfilterLogsRequest struct {
	ctx        context.Context
	ApiService *LogsApiService
	count      float32
	xAPIKey    *string
}

// e.g. api-key-string
func (r ApiGetNetfilterLogsRequest) XAPIKey(xAPIKey string) ApiGetNetfilterLogsRequest {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetNetfilterLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetNetfilterLogsExecute(r)
}

/*
GetNetfilterLogs Get Netfilter logs

This Api endpoint lists all Netfilter logs.
Tip: You can limit how many logs you want to get by using `/<count>` at the end of the api url.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param count Number of logs to return
 @return ApiGetNetfilterLogsRequest
*/
func (a *LogsApiService) GetNetfilterLogs(ctx context.Context, count float32) ApiGetNetfilterLogsRequest {
	return ApiGetNetfilterLogsRequest{
		ApiService: a,
		ctx:        ctx,
		count:      count,
	}
}

// Execute executes the request
func (a *LogsApiService) GetNetfilterLogsExecute(r ApiGetNetfilterLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogsApiService.GetNetfilterLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/get/logs/netfilter/{count}"
	localVarPath = strings.Replace(localVarPath, "{"+"count"+"}", url.PathEscape(parameterToString(r.count, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v CreateAlias401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPostfixLogsRequest struct {
	ctx        context.Context
	ApiService *LogsApiService
	count      float32
	xAPIKey    *string
}

// e.g. api-key-string
func (r ApiGetPostfixLogsRequest) XAPIKey(xAPIKey string) ApiGetPostfixLogsRequest {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetPostfixLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPostfixLogsExecute(r)
}

/*
GetPostfixLogs Get Postfix logs

This Api endpoint lists all Postfix logs.
Tip: You can limit how many logs you want to get by using `/<count>` at the end of the api url.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param count Number of logs to return
 @return ApiGetPostfixLogsRequest
*/
func (a *LogsApiService) GetPostfixLogs(ctx context.Context, count float32) ApiGetPostfixLogsRequest {
	return ApiGetPostfixLogsRequest{
		ApiService: a,
		ctx:        ctx,
		count:      count,
	}
}

// Execute executes the request
func (a *LogsApiService) GetPostfixLogsExecute(r ApiGetPostfixLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogsApiService.GetPostfixLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/get/logs/postfix/{count}"
	localVarPath = strings.Replace(localVarPath, "{"+"count"+"}", url.PathEscape(parameterToString(r.count, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v CreateAlias401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRatelimitLogsRequest struct {
	ctx        context.Context
	ApiService *LogsApiService
	count      float32
	xAPIKey    *string
}

// e.g. api-key-string
func (r ApiGetRatelimitLogsRequest) XAPIKey(xAPIKey string) ApiGetRatelimitLogsRequest {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetRatelimitLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRatelimitLogsExecute(r)
}

/*
GetRatelimitLogs Get Ratelimit logs

This Api endpoint lists all Ratelimit logs.
Tip: You can limit how many logs you want to get by using `/<count>` at the end of the api url.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param count Number of logs to return
 @return ApiGetRatelimitLogsRequest
*/
func (a *LogsApiService) GetRatelimitLogs(ctx context.Context, count float32) ApiGetRatelimitLogsRequest {
	return ApiGetRatelimitLogsRequest{
		ApiService: a,
		ctx:        ctx,
		count:      count,
	}
}

// Execute executes the request
func (a *LogsApiService) GetRatelimitLogsExecute(r ApiGetRatelimitLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogsApiService.GetRatelimitLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/get/logs/ratelimited/{count}"
	localVarPath = strings.Replace(localVarPath, "{"+"count"+"}", url.PathEscape(parameterToString(r.count, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v CreateAlias401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRspamdLogsRequest struct {
	ctx        context.Context
	ApiService *LogsApiService
	count      float32
	xAPIKey    *string
}

// e.g. api-key-string
func (r ApiGetRspamdLogsRequest) XAPIKey(xAPIKey string) ApiGetRspamdLogsRequest {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetRspamdLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRspamdLogsExecute(r)
}

/*
GetRspamdLogs Get Rspamd logs

This Api endpoint lists all Rspamd logs.
Tip: You can limit how many logs you want to get by using `/<count>` at the end of the api url.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param count Number of logs to return
 @return ApiGetRspamdLogsRequest
*/
func (a *LogsApiService) GetRspamdLogs(ctx context.Context, count float32) ApiGetRspamdLogsRequest {
	return ApiGetRspamdLogsRequest{
		ApiService: a,
		ctx:        ctx,
		count:      count,
	}
}

// Execute executes the request
func (a *LogsApiService) GetRspamdLogsExecute(r ApiGetRspamdLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogsApiService.GetRspamdLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/get/logs/rspamd-history/{count}"
	localVarPath = strings.Replace(localVarPath, "{"+"count"+"}", url.PathEscape(parameterToString(r.count, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v CreateAlias401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSOGoLogsRequest struct {
	ctx        context.Context
	ApiService *LogsApiService
	count      float32
	xAPIKey    *string
}

// e.g. api-key-string
func (r ApiGetSOGoLogsRequest) XAPIKey(xAPIKey string) ApiGetSOGoLogsRequest {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetSOGoLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSOGoLogsExecute(r)
}

/*
GetSOGoLogs Get SOGo logs

This Api endpoint lists all SOGo logs.
Tip: You can limit how many logs you want to get by using `/<count>` at the end of the api url.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param count Number of logs to return
 @return ApiGetSOGoLogsRequest
*/
func (a *LogsApiService) GetSOGoLogs(ctx context.Context, count float32) ApiGetSOGoLogsRequest {
	return ApiGetSOGoLogsRequest{
		ApiService: a,
		ctx:        ctx,
		count:      count,
	}
}

// Execute executes the request
func (a *LogsApiService) GetSOGoLogsExecute(r ApiGetSOGoLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogsApiService.GetSOGoLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/get/logs/sogo/{count}"
	localVarPath = strings.Replace(localVarPath, "{"+"count"+"}", url.PathEscape(parameterToString(r.count, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v CreateAlias401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetWatchdogLogsRequest struct {
	ctx        context.Context
	ApiService *LogsApiService
	count      float32
	xAPIKey    *string
}

// e.g. api-key-string
func (r ApiGetWatchdogLogsRequest) XAPIKey(xAPIKey string) ApiGetWatchdogLogsRequest {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetWatchdogLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetWatchdogLogsExecute(r)
}

/*
GetWatchdogLogs Get Watchdog logs

This Api endpoint lists all Watchdog logs.
Tip: You can limit how many logs you want to get by using `/<count>` at the end of the api url.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param count Number of logs to return
 @return ApiGetWatchdogLogsRequest
*/
func (a *LogsApiService) GetWatchdogLogs(ctx context.Context, count float32) ApiGetWatchdogLogsRequest {
	return ApiGetWatchdogLogsRequest{
		ApiService: a,
		ctx:        ctx,
		count:      count,
	}
}

// Execute executes the request
func (a *LogsApiService) GetWatchdogLogsExecute(r ApiGetWatchdogLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogsApiService.GetWatchdogLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/get/logs/watchdog/{count}"
	localVarPath = strings.Replace(localVarPath, "{"+"count"+"}", url.PathEscape(parameterToString(r.count, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v CreateAlias401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
